Understood. I will create a precise, exhaustive to-do list for implementing the admin `sudo` command and the `maintenance` CLI switch, along with Stripe webhook protection during maintenance, strictly according to the implementation blueprint.

I’ll begin preparing the full list of implementation steps, CLI code structure, database constraints, 2FA guardrails, audit logging, middleware behavior, and webhook idempotency logic. I’ll let you know as soon as it’s ready.


# Implementation To-Do List for Admin Impersonation & Maintenance Features

## CLI Enhancements (Admin & Maintenance Commands)

* **Add `admin:sudo <account_id>` CLI Command:** In the custom CLI (`/apps/cli`), define a new command `admin:sudo` that accepts a target tenant’s `<account_id>` as an argument. This command should only be usable by the platform’s seeded admin (founder) account. Validate the provided `<account_id>` (ensure the account exists in `public.accounts`). If validation passes, prompt the admin for a 2FA verification code (TOTP or similar) and **verify the code** against the admin’s 2FA secret (the admin must complete a 2FA challenge before impersonation). If the code is incorrect or times out, abort the command with an error.

* **Generate Time-Boxed Admin JWT for Impersonation:** Upon successful 2FA, generate a special JSON Web Token (JWT) that impersonates the target tenant. Use the Supabase JWT signing secret (from config) to create a token with the admin **as the issuer** but with the target’s `account_id` in the custom claims. Set the JWT’s `role` claim to an elevated role (e.g. `"service_role"` or a dedicated cross-tenant admin role) so it bypasses RLS and can access the tenant’s schema. Limit the token’s lifetime (expiration claim) to a short window (e.g. 15 minutes) to ensure **time-boxed** access for emergency support. Output the JWT on the console (so the admin can use it in an Authorization header or in the client app to assume the tenant’s context).

* **Require Reason and Log Audit Trail for Sudo Access:** Require the admin to provide a reason or ticket ID for the sudo session (either as a command option or via prompt). Immediately record an **audit log** entry in `public.audit_log` documenting the sudo event. The log should include: the admin’s user ID (actor), the target `account_id` (tenant being impersonated), a description (e.g. “Admin sudo access”), the provided reason, and a timestamp. Implement this insertion using the Supabase service-role database client (to bypass RLS and allow writing to the audit table). Ensure the audit log entry is written **before** issuing the token, so that any access is accounted for even if further steps fail. Also log the event to the CLI output for confirmation. (The audit log will be used for compliance/SOC2 evidence of cross-tenant access.)

* **Safety Checks in `admin:sudo`:** Before issuing the token, double-check that the target account is active and not itself in a locked state (e.g. not cancelled). If the target account has `maintenance_mode` or other flags set, still allow access (the goal is to troubleshoot such states). However, print a warning if the account is suspended. Also ensure the CLI uses environment-stored **service role credentials** to perform any DB lookups or inserts (like verifying account existence and writing audit logs) so that these operations bypass normal RLS restrictions securely. No regular user credentials should be used in this flow – it must run with **superset privileges** but constrained by code to only the intended tasks.

* **Implement `maintenance --on/--off` CLI Command:** Extend the CLI with a `maintenance` command (or two subcommands `maintenance:on` and `maintenance:off`). This command toggles the platform’s **global maintenance mode**. Parse the flag (`--on` or `--off`) and determine the desired state. Using the service-role DB client, update the `public.settings` table’s `maintenance_all` key to `"true"` or `"false"` accordingly. The update should flip the `value` for the key `maintenance_all` (which is used to indicate if the entire platform is in read-only maintenance). Use an UPSERT if the key does not exist. On success, print a confirmation (e.g. “Maintenance mode enabled” or “Maintenance mode disabled”).

* **Audit Log for Maintenance Toggles:** Whenever maintenance mode is toggled via the CLI, insert a record into `public.audit_log` to track this privileged action. The log entry should include the admin user (actor), the action (“maintenance\_on” or “maintenance\_off”), and a timestamp. If `--on`, optionally include a short reason (which could be passed as an optional CLI argument, e.g. “--reason deploying migration”) to explain why the platform was put into maintenance. This provides an audit trail for platform downtime events. Use the service-role client for this insert so it bypasses RLS and security checks, since it’s an internal admin action.

* **CLI Command Security & Testing:** Restrict these new CLI commands to **admin use only**. In practice, the CLI is a developer tool, but add safeguards: for example, check an environment variable like `OZZA_ADMIN_EMAIL` or a config file to ensure the current user matches the founder’s email before allowing `admin:sudo` or `maintenance` commands to run. Write unit tests or integration tests for the CLI: e.g. simulate running `admin:sudo` with a valid account ID and verify it outputs a token and writes an audit log entry; simulate an invalid 2FA code to ensure it refuses access. Similarly, test `maintenance --on` and `--off` commands: after running, verify the `maintenance_all` flag in the DB is updated and an audit record is created. These tests ensure the CLI commands behave as expected and only in intended scenarios.

## Database & Schema Updates

* **Add `maintenance_all` to Global Settings:** In the database schema (migrations under `/packages/db/migrations`), ensure there is a `public.settings` table for global flags. Add a new row (or modify the seed data) for the key `maintenance_all` (type boolean stored as text or a boolean type) with default `false` meaning normal operation. This global flag will be flipped to `true` during maintenance windows to put the platform in read-only mode. The CLI will update this value, and the app will read it to enforce maintenance behavior.

* **Audit Log Table:** Ensure the `public.audit_log` table exists (create it via a migration if not present) to track security-sensitive events. Include columns such as: `id` (serial or UUID PK), `timestamp` (default now()), `actor_user_id` (UUID of the admin or user performing the action), `target_account_id` (UUID of the affected tenant, if applicable), `action` (text descriptor, e.g. “admin\_sudo”, “maintenance\_on”), and `details` (text or JSON for additional info like reason or data accessed). This table will capture events like admin sudo access, maintenance mode toggles, cross-tenant data exports, etc. Add a migration to create this table and relevant indexes (e.g. index on `timestamp` or `target_account_id` if needed for queries).

* **Account Maintenance Mode Field:** Verify the `public.accounts` table has a boolean field `maintenance_mode` for per-tenant read-only status. If not already present, add `maintenance_mode BOOLEAN DEFAULT false` via a migration. This field is used to suspend individual accounts (e.g. for billing issues) without affecting others. Ensure the default is false and that all existing accounts start in active mode. Also confirm there are fields for `plan_status` (to track billing state like active/past\_due) that the Stripe webhook will update.

* **Row-Level Security (RLS) Policies:** Update RLS policies to protect the new and sensitive tables:

  * For `public.settings`: Enable RLS (if not already) and create a policy that **prevents regular authenticated users from selecting or modifying** global settings. Only the service role and perhaps a designated “platform\_admin” role should be allowed. For example, allow `SELECT` on `settings` to no one (or only to service role, since the app itself will use the service key to read it), and allow `UPDATE`/`UPSERT` on `maintenance_all` only to the service role (as used by the CLI or a secure function). This ensures tenants cannot flip maintenance mode or read other sensitive toggles.
  * For `public.audit_log`: Enable RLS. By default, disallow all `SELECT` to normal users (since it contains cross-tenant info). Create an exception policy for the platform admin: if we have a way to identify the admin in the DB (e.g. a role or a specific admin user ID), allow that to select all rows. Insertions will always be done via the service role (CLI or server function), so we can either allow inserts for the service role or use `SECURITY DEFINER` functions to write to it. The goal is that only privileged contexts can write/read audit logs. (If needed, also allow a tenant owner to select audit logs that pertain to their own account, e.g. where `target_account_id` = their account, so they can see when a coach or admin accessed their data. This can be a later enhancement – for now, platform admin can review the logs for compliance.)

* **Supabase Metadata & Migrations:** Update the Supabase migration files to include the above changes. Ensure no destructive changes are introduced (per the additive-only rule) – new columns and new tables are fine. Run `supabase db push` or migration commands to apply in dev. Also update any seed data script to insert the `maintenance_all` setting and possibly a row in `accounts` for the platform admin user (if not already present). The platform admin could be represented as an entry in `account_members` linking the admin user to every account or by a special account; check blueprint guidance for seeding a “platform admin” user and implement accordingly so that the admin’s Supabase Auth user exists with elevated privileges.

* **Billing Events Log:** Confirm the `public.billing_events` table (for Stripe webhook idempotency) exists with structure: `event_id` (text PK), `event_type`, `account_id`, `processed_at`. No changes needed here beyond using it, but ensure it’s part of the schema. This table is crucial for Stripe webhook resilience: on each webhook, the function will insert the `event_id` after successful processing; if an event comes in again (retry), the function will detect the existing ID and skip processing. Make sure this table has RLS disabled or a policy that allows the service role to insert/select (regular users won’t access it at all).

## Next.js Middleware & Read-Only Mode Enforcement

* **Global Maintenance Mode Check in Middleware:** Implement logic in the Next.js middleware (`/apps/web/middleware.ts`) to enforce the global maintenance mode across the app. On each incoming request, **check the `maintenance_all` flag** from the database (or a cached config). This can be done by querying the `public.settings` table for `maintenance_all`. (To avoid a DB call on every request, you might load this setting at startup or cache it for a short interval, but ensure changes will propagate quickly – since maintenance mode is used sparingly, a slight delay is acceptable.) If `maintenance_all = true`, then for any non-admin user request, bypass the normal app flow and redirect to a **maintenance notice page**. Create a simple maintenance page (e.g. `/maintenance` route or a static HTML) that informs users the platform is in read-only maintenance and to check back later. The middleware should redirect all GET requests to this page, and for non-GET (write) requests it can return a 503 response or an error JSON indicating maintenance (to cover API calls).

* **Admin Override in Middleware:** The middleware should **allow platform admin traffic through even during maintenance**. Determine a reliable way to identify admin requests. For example, if the admin uses the special JWT from `admin:sudo` (with role `service_role` or a custom claim), decode the JWT in middleware and check its role/claims. If the JWT indicates an admin (or if the request is coming from a known admin origin/IP in a pinch), then **do not redirect** – allow the admin to access the app to perform checks or emergency actions despite maintenance mode. (Similarly, if the request is for the Stripe webhook endpoint, which might not go through Next.js, it should not be blocked – see Edge Functions section.) Implement this by checking `req.headers.authorization` for the admin token or a cookie if the admin logs in via the app. *Note:* In a GA scenario, we could have the admin log in normally and have a claim like `is_admin=true` in their JWT, in which case check that claim. The blueprint suggests possibly using the service-role JWT as the override, so using the presence of a service role token is a simple indicator.

* **Per-Tenant Maintenance (Billing Suspension) Enforcement:** In addition to global maintenance, ensure the app respects the per-account `maintenance_mode` field. This will typically be handled in the application logic: e.g. whenever fetching the current account’s status (after user login), include `maintenance_mode`. If a tenant’s `maintenance_mode` is true (meaning that account is suspended, usually for billing issues), the UI should display a banner like “Your account is in read-only mode due to an issue (e.g. payment failure)”. Allow the user (especially the Owner) to navigate to the billing/settings page even in this state, so they can resolve the issue (update payment method). However, **prevent all write operations** for this tenant until `maintenance_mode` is false. Concretely, implement checks in API routes or server actions: any state-changing request should verify `req.user.account.maintenance_mode` – if true, and the request is not whitelisted (like a payment update), respond with an error (or no-op) indicating the account is read-only. Front-end forms should also be disabled in this state to give immediate UX feedback. This double-check ensures suspended accounts cannot modify data, fulfilling the “read-only with banner” requirement.

* **Maintenance UX and Overrides:** Develop the maintenance notice page and in-app banner:

  * The **maintenance page** (for global downtime) should be a simple public page (no auth required) explaining the platform is under maintenance and possibly an ETA. The middleware will redirect all users here when `maintenance_all` is true.
  * The **account suspension banner** should be integrated into the main app layout. If `maintenance_mode` is true for the logged-in user’s account, display a prominent banner on every page (except maybe the billing page) stating the account is in read-only mode due to billing issues. Also hide or disable any “Save” or “Edit” buttons to prevent user attempts. If the user is an Owner, include a link in the banner to “Update Billing Information” which directs to the Stripe customer portal or billing page (this route remains accessible even in maintenance).
  * Ensure that **even if maintenance\_all is active, the Stripe billing update flow can proceed for suspended accounts**. In global maintenance, ideally no users are in the app at all (so this might not apply), but in account-level maintenance, we explicitly allow billing updates. So, for account-level maintenance, do not block the route that leads to updating payment (or the external Stripe portal). You can implement this by not applying the write-block on requests to the billing settings endpoint.

* **Testing Middleware & Maintenance Behavior:** Test the maintenance mode end-to-end:

  * When `maintenance_all` is set to true (via the CLI or directly in DB in a dev environment), simulate a normal user request to a protected page and verify that the middleware responds with a redirect to the maintenance page (or a 503 for API calls). Then simulate an admin request (using an admin JWT in the Authorization header) and ensure the request is **not** redirected but proceeds normally (admin can load the app).
  * Test that when a tenant’s `maintenance_mode` is true (simulate a billing failure scenario), a normal user from that tenant cannot perform write operations: try calling a data update API route and expect a 403 or error stating the account is read-only. Also check that read operations still succeed (they can fetch and view data). Verify the UI: the maintenance banner appears for that user and editing UI is disabled.
  * Test that the Owner of a suspended account can still access the billing page or Stripe portal link. Attempt a payment method update (this might be done by hitting a test route or just verifying the link is accessible).
  * Finally, toggle `maintenance_all` back to false via CLI and ensure the middleware stops redirecting and normal operations resume. All these test scenarios should be automated if possible (in integration tests or E2E tests) to avoid regressions.

## Supabase Edge Function – Stripe Webhook Resilience

* **Idempotent Webhook Processing:** In the Stripe webhook function (`supabase/functions/stripe-webhook/index.ts`), implement robust, idempotent handling of events. Before processing an incoming event, **check the `billing_events` table** for the event’s ID (e.g. `evt_12345`). If an entry with that `event_id` exists, it means we’ve already processed this event, so skip any further action and return HTTP 200 immediately (acknowledging receipt with no duplicate effect). If not, proceed to process the event. After successful processing of an event, insert a new record into `billing_events` with that `event_id`, event type, target account, and processed timestamp. This ensures that if Stripe retries the event (which can happen during maintenance or network issues), the subsequent call will see the event in the log and perform a quick no-op, preventing duplicate updates.

* **Handle Maintenance-Mode Related Events:** Some Stripe events trigger account maintenance changes. Implement logic for those:

  * On subscription or invoice payment failure events (e.g. `invoice.payment_failed` or `customer.subscription.updated` with status = past\_due), set the corresponding account’s `plan_status` to `past_due` and **flip `maintenance_mode = true`** for that account in `public.accounts`. This will put that tenant in read-only mode until they resolve billing. Ensure this update is done with the Supabase admin client (service role) since it’s a cross-tenant write. Also, consider logging this action (could insert an audit\_log entry “account auto-suspended for non-payment” with account and time).
  * On payment success or subscription renewal events (e.g. `invoice.payment_succeeded`, or `customer.subscription.updated` with status = active after a past\_due), update the account’s `plan_status` back to `active` and **set `maintenance_mode = false`**. This unsuspends the account so they regain write access. Also record the new plan details if the plan changed.
  * On `customer.subscription.deleted` (cancellation), handle according to business rules (e.g. downgrade to free plan or lock the account if no free tier). If we choose to lock on cancel with no fallback, that might also use maintenance\_mode (though the blueprint suggests possibly preventing login in that case) – implement per blueprint specifics.
  * All these updates must be carefully tested to ensure the correct accounts are updated and no other data is touched (principle of least privilege in code).

* **Graceful Behavior During Global Maintenance:** Ensure the Stripe webhook function is resilient if called during a global maintenance window (e.g. during a deployment). **Check the `maintenance_all` flag** at the start of the function by querying `public.settings`. If `maintenance_all = true`, decide on a safe course of action:

  * The simplest approach is to **not process events during this window**, to avoid conflicts with migrations. In this case, log that the platform is in maintenance and immediately return an HTTP 503 or 500 error without processing the event. This signals to Stripe that the attempt failed, so Stripe will retry the webhook later. (Stripe will retry events for up to 72 hours, so the event will be delivered once maintenance is over.) By intentionally not processing, we avoid any risk of partial updates if the database is mid-migration.
  * Alternatively, if we choose to allow processing (for example, if the maintenance is just a brief read-only period but DB is accessible), ensure that the function’s database writes are wrapped in a transaction and handle any errors gracefully. In either case, do **not acknowledge (200)** an event that wasn’t fully processed; respond with an error so Stripe knows to retry. This way, no billing event is lost even if it comes in during downtime.
  * Implement logging within the function to record if an event was received during maintenance and was deferred. This helps with debugging and assurance that the mechanism works.

* **Use Service-Role DB Access:** Configure the Stripe webhook function to use Supabase’s service role key for all database operations. This is typically done via an environment variable (`SUPABASE_SERVICE_ROLE_KEY`) loaded in the function. Using the service role ensures the function can bypass RLS and update any necessary table (accounts, subscriptions, billing\_events, etc.) across tenant schemas. All updates should still be constrained in code: the function should only touch billing-related fields and tables (for example, flip an account’s status, insert a billing event, maybe update `account_features` if plan changes) and nothing else. Maintain narrow scope to uphold security even with broad DB rights.

* **Test Stripe Webhook Resilience:** Simulate various Stripe webhook scenarios to confirm reliable behavior:

  * Send a test event (using Stripe’s CLI or test mode) for a **payment failure** and verify that the target account’s `maintenance_mode` becomes `true` in the DB and the event is logged in `billing_events`. The account should then be in read-only mode (which you can confirm by trying a write as that account and expecting a failure).
  * Then send a corresponding **payment succeeded** event (or resolve the invoice in Stripe’s dashboard and let the webhook come through) and verify `maintenance_mode` flips back to `false` and the account is reactivated.
  * Test **duplicate events**: send the same webhook payload (with same `event_id`) twice. The first call should process and insert into `billing_events`; the second call should detect the duplicate `event_id` and skip processing, returning 200 without side effects.
  * Test **maintenance window scenario**: turn on `maintenance_all` (perhaps by temporarily simulating a deploy in a test environment or toggling the flag), then send a Stripe event. Verify that the function responds with an error (e.g. 500) and does not insert a `billing_event` record for that attempt. Then turn off maintenance and **send the event again (or let Stripe retry)** – this time it should process successfully and log the event. Ensure that ultimately the event gets applied when maintenance is over (this may be observed via Stripe’s retry log and the presence of the event in our `billing_events`). This confirms no event is lost during maintenance.
  * Include edge cases like an unknown event type: the function should return 200 immediately for events we don’t handle (so Stripe won’t retry those). Also simulate a DB error (e.g., by pointing the DB client to a wrong table in a test build) to ensure the function correctly returns 500 on failure and that Stripe’s retry logic would kick in.
  * These tests can be automated or run in a staging environment. Leverage the blueprint’s guidance on using Stripe’s test toolkit for webhooks and integration testing to cover these cases. The goal is to verify **auditability and resilience**: every critical action is logged and no billing update is missed, even during planned downtime.
